package sfacg

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"path"
	"sf/config"
	"sf/structs"
	"strconv"
)

type ChapterJson struct {
	ID       string `json:"id"`
	Title    string `json:"title"`
	Index    int    `json:"index"`
	IsVip    bool   `json:"is_vip"`
	VolumeID string `json:"volume_id"`
	Content  string `json:"content"`
}
type TestChapterConfig struct {
	ChapterInfo []ChapterJson
	BookName    string
}

func TestInit(bookName string) *TestChapterConfig {
	var AutoGenerateds []ChapterJson
	if data, ok := ioutil.ReadFile("./config/" + bookName + ".json"); ok == nil {
		if err := json.Unmarshal(data, &AutoGenerateds); err != nil {
			fmt.Println(err)
		}
	}
	return &TestChapterConfig{ChapterInfo: AutoGenerateds, BookName: bookName}
}

func (is *TestChapterConfig) In(ChapID string) bool {
	for _, s := range is.ChapterInfo {
		if s.ID == ChapID {
			return true
		}
	}
	return false
}
func (is *TestChapterConfig) merge(VolumeList []structs.VolumeList) {
	for _, data := range VolumeList {
		fmt.Println(data.Title, "merge complete")
		for _, Chapter := range data.ChapterList {
			for _, info := range is.ChapterInfo {
				if info.ID == strconv.Itoa(Chapter.ChapID) {
					content := "\n\n\n" + info.Title + "\n" + info.Content
					config.Writes(path.Join("save", is.BookName+".txt"), content)
				}
			}
		}
	}
}

func (is *TestChapterConfig) SaveContent() {
	if save, ok := json.MarshalIndent(is.ChapterInfo, "", "    "); ok == nil {
		if err := ioutil.WriteFile("./config/"+is.BookName+".json", save, 0777); err != nil {
			fmt.Println(err)
		}
	} else {
		fmt.Println("SaveContent", ok)
	}

}
